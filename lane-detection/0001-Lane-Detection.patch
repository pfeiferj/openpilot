From dd082a22669941df32a2b0138411ae67670bb832 Mon Sep 17 00:00:00 2001
From: Jacob Pfeifer <jacob@pfeifer.dev>
Date: Fri, 28 Jul 2023 22:30:49 -0400
Subject: [PATCH] Lane Detection

Prevents lane changes whenever there is no lane detected.
---
 common/params.cc                          |  4 ++
 selfdrive/controls/lane_detection.py      | 51 +++++++++++++++++++++++
 selfdrive/controls/lib/desire_helper.py   |  7 ++++
 selfdrive/controls/lib/lateral_planner.py |  6 +++
 selfdrive/ui/qt/offroad/settings.cc       |  8 ++++
 5 files changed, 76 insertions(+)
 create mode 100644 selfdrive/controls/lane_detection.py

diff --git a/common/params.cc b/common/params.cc
index e8ab42c0b..99fd6e2bf 100644
--- a/common/params.cc
+++ b/common/params.cc
@@ -206,6 +206,10 @@ std::unordered_map<std::string, uint32_t> keys = {
     {"Version", PERSISTENT},
     {"VisionRadarToggle", PERSISTENT},
     {"WheeledBody", PERSISTENT},
+
+    // PFEIFER - LD {{
+    {"LaneDetection", PERSISTENT},
+    // }} PFEIFER - LD
 };
 
 } // namespace
diff --git a/selfdrive/controls/lane_detection.py b/selfdrive/controls/lane_detection.py
new file mode 100644
index 000000000..5940ba095
--- /dev/null
+++ b/selfdrive/controls/lane_detection.py
@@ -0,0 +1,51 @@
+# PFEIFER - LD
+
+# Acknowledgements:
+# Lane detection logic was pulled from frogpilot. A huge thanks to FrogAi! https://github.com/FrogAi/FrogPilot
+
+import numpy as np
+from common.params import Params
+params = Params()
+
+class LaneDetection:
+  lane_lines = []
+
+  @property
+  def enabled(self) -> bool:
+    try:
+      return params.get_bool("LaneDetection")
+    except:
+      return False
+
+  def update(self, model):
+    self.lane_lines = model.laneLines
+
+
+  def lane_valid(self, one_blinker: bool, carstate):
+    enabled = self.enabled
+    if not enabled:
+      return True
+
+    if not one_blinker:
+      return False
+
+    # Set the minimum lane threshold to 2.8 meters
+    min_lane_threshold = 2.8
+    # Set the blinker index based on which signal is on
+    blinker_index = 0 if carstate.leftBlinker else 1
+    current_lane = self.lane_lines[blinker_index + 1]
+    desired_lane = self.lane_lines[blinker_index] if carstate.leftBlinker else self.lane_lines[blinker_index + 2]
+    # Check if both the desired lane and the current lane have valid x and y values
+    if all([desired_lane.x, desired_lane.y, current_lane.x, current_lane.y]) and len(desired_lane.x) == len(current_lane.x):
+      # Interpolate the x and y values to the same length
+      x = np.linspace(desired_lane.x[0], desired_lane.x[-1], num=len(desired_lane.x))
+      lane_y = np.interp(x, current_lane.x, current_lane.y)
+      desired_y = np.interp(x, desired_lane.x, desired_lane.y)
+      # Calculate the width of the lane we're wanting to change into
+      lane_width = np.abs(desired_y - lane_y)
+      # Set lane_available to True if the lane width is larger than the threshold
+      return np.amax(lane_width) >= min_lane_threshold
+    else:
+      return False
+
+ld = LaneDetection()
diff --git a/selfdrive/controls/lib/desire_helper.py b/selfdrive/controls/lib/desire_helper.py
index 4652b41c1..8f2e9e2ca 100644
--- a/selfdrive/controls/lib/desire_helper.py
+++ b/selfdrive/controls/lib/desire_helper.py
@@ -1,6 +1,9 @@
 from cereal import log
 from common.conversions import Conversions as CV
 from common.realtime import DT_MDL
+# PFEIFER - LD {{
+from selfdrive.controls.lane_detection import ld
+# }} PFEIFER - LD
 
 LaneChangeState = log.LateralPlan.LaneChangeState
 LaneChangeDirection = log.LateralPlan.LaneChangeDirection
@@ -72,6 +75,10 @@ class DesireHelper:
           self.lane_change_direction = LaneChangeDirection.none
         elif torque_applied and not blindspot_detected:
           self.lane_change_state = LaneChangeState.laneChangeStarting
+          # PFEIFER - LD {{
+          if not ld.lane_valid(one_blinker, carstate):
+            self.lane_change_state = LaneChangeState.preLaneChange
+          # }} PFEIFER - LD
 
       # LaneChangeState.laneChangeStarting
       elif self.lane_change_state == LaneChangeState.laneChangeStarting:
diff --git a/selfdrive/controls/lib/lateral_planner.py b/selfdrive/controls/lib/lateral_planner.py
index 591431242..349cb1900 100644
--- a/selfdrive/controls/lib/lateral_planner.py
+++ b/selfdrive/controls/lib/lateral_planner.py
@@ -8,6 +8,9 @@ from selfdrive.controls.lib.drive_helpers import CONTROL_N, MIN_SPEED, get_speed
 from selfdrive.controls.lib.desire_helper import DesireHelper
 import cereal.messaging as messaging
 from cereal import log
+# PFEIFER - LD {{
+from selfdrive.controls.lane_detection import ld
+# }} PFEIFER - LD
 
 TRAJECTORY_SIZE = 33
 CAMERA_OFFSET = 0.04
@@ -77,6 +80,9 @@ class LateralPlanner:
       self.l_lane_change_prob = desire_state[log.LateralPlan.Desire.laneChangeLeft]
       self.r_lane_change_prob = desire_state[log.LateralPlan.Desire.laneChangeRight]
     lane_change_prob = self.l_lane_change_prob + self.r_lane_change_prob
+    # PFEIFER - LD {{
+    ld.update(md)
+    # }} PFEIFER - LD
     self.DH.update(sm['carState'], sm['carControl'].latActive, lane_change_prob)
 
     self.lat_mpc.set_weights(PATH_COST, LATERAL_MOTION_COST,
diff --git a/selfdrive/ui/qt/offroad/settings.cc b/selfdrive/ui/qt/offroad/settings.cc
index 94a673dd7..3040eebef 100644
--- a/selfdrive/ui/qt/offroad/settings.cc
+++ b/selfdrive/ui/qt/offroad/settings.cc
@@ -69,6 +69,14 @@ TogglesPanel::TogglesPanel(SettingsWindow *parent) : ListWidget(parent) {
       tr("Display speed in km/h instead of mph."),
       "../assets/offroad/icon_metric.png",
     },
+    // PFEIFER - LD {{
+    {
+      "LaneDetection",
+      tr("Lane Detection"),
+      tr("Prevents lane changes whenever a lane is not detected."),
+      "../assets/img_experimental_white.svg",
+    },
+    // }} PFEIFER - LD
 #ifdef ENABLE_MAPS
     {
       "NavSettingTime24h",
-- 
2.41.0

